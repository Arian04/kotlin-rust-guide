<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A guide to Rust for Kotlin developers</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="This book should help experienced Kotlin developers to quickly get up to speed with Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="ferris.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="basics.html"><strong aria-hidden="true">1.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics_syntax.html"><strong aria-hidden="true">1.1.</strong> Syntax differences</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">1.2.</strong> Macros</a></li><li class="chapter-item expanded "><a href="basics_primitives.html"><strong aria-hidden="true">1.3.</strong> Primitives</a></li></ol></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">2.</strong> Types and variables</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types_mutability.html"><strong aria-hidden="true">2.1.</strong> Mutability</a></li><li class="chapter-item expanded "><a href="types_strings.html"><strong aria-hidden="true">2.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="types_commmon.html"><strong aria-hidden="true">2.3.</strong> Common types</a></li><li class="chapter-item expanded "><a href="types_constants.html"><strong aria-hidden="true">2.4.</strong> Constants</a></li></ol></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">3.</strong> References</a></li><li class="chapter-item expanded "><a href="borrowing.html"><strong aria-hidden="true">4.</strong> Borrowing and Ownership</a></li><li class="chapter-item expanded "><a href="classes.html"><strong aria-hidden="true">5.</strong> Classes, or the lack there of</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="classes_deriving.html"><strong aria-hidden="true">5.1.</strong> Deriving and implementing</a></li><li class="chapter-item expanded "><a href="classes_default.html"><strong aria-hidden="true">5.2.</strong> Default</a></li></ol></li><li class="chapter-item expanded "><a href="methods.html"><strong aria-hidden="true">6.</strong> Methods</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="methods_self.html"><strong aria-hidden="true">6.1.</strong> this/self</a></li><li class="chapter-item expanded "><a href="methods_functional.html"><strong aria-hidden="true">6.2.</strong> Functional Programming</a></li></ol></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">7.</strong> Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="modules_directories.html"><strong aria-hidden="true">7.1.</strong> Directories</a></li></ol></li><li class="chapter-item expanded "><a href="crates.html"><strong aria-hidden="true">8.</strong> Crates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="crates_adding.html"><strong aria-hidden="true">8.1.</strong> Adding crates</a></li><li class="chapter-item expanded "><a href="crates_standard.html"><strong aria-hidden="true">8.2.</strong> Not in standard</a></li><li class="chapter-item expanded "><a href="crates_common.html"><strong aria-hidden="true">8.3.</strong> Common crates</a></li></ol></li><li class="chapter-item expanded "><a href="result.html"><strong aria-hidden="true">9.</strong> Result, Option and Exceptions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="result_exception.html"><strong aria-hidden="true">9.1.</strong> Result and exceptions</a></li><li class="chapter-item expanded "><a href="result_option.html"><strong aria-hidden="true">9.2.</strong> Option and nulls</a></li></ol></li><li class="chapter-item expanded "><a href="concurrency.html"><strong aria-hidden="true">10.</strong> Concurrency</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li class="chapter-item expanded "><a href="cargo.html"><strong aria-hidden="true">12.</strong> Cargo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cargo_tools.html"><strong aria-hidden="true">12.1.</strong> Tools</a></li></ol></li><li class="chapter-item expanded "><a href="enums.html"><strong aria-hidden="true">13.</strong> Enums</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="enums_crates.html"><strong aria-hidden="true">13.1.</strong> Useful crates</a></li></ol></li><li class="chapter-item expanded "><a href="tips.html"><strong aria-hidden="true">14.</strong> Tips and tricks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tips_iflet.html"><strong aria-hidden="true">14.1.</strong> if let</a></li><li class="chapter-item expanded "><a href="tips_refcount.html"><strong aria-hidden="true">14.2.</strong> Reference counting</a></li><li class="chapter-item expanded "><a href="tips_strings.html"><strong aria-hidden="true">14.3.</strong> Converting strings</a></li><li class="chapter-item expanded "><a href="tips_intmut.html"><strong aria-hidden="true">14.4.</strong> Interior mutability</a></li><li class="chapter-item expanded "><a href="tips_enumiter.html"><strong aria-hidden="true">14.5.</strong> Indexed iteration</a></li><li class="chapter-item expanded "><a href="tips_formatting.html"><strong aria-hidden="true">14.6.</strong> Formatting strings</a></li><li class="chapter-item expanded "><a href="tips_crates.html"><strong aria-hidden="true">14.7.</strong> For crates</a></li></ol></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">15.</strong> Common bugs/issues</a></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">16.</strong> Architecture</a></li><li class="chapter-item expanded affix "><a href="resources.html">Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">A guide to Rust for Kotlin developers</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#a-guide-to-rust-for-kotlin-developers" id="a-guide-to-rust-for-kotlin-developers">A guide to Rust for Kotlin developers</a></h1>
<p>This guide should help developers experienced with Kotlin quickly and easily learn the basics of Rust by comparing the major differences but also how the languages, by the nature of them both being modern languages, have quite a few similar features.</p>
<p>This book is a summary of the official Rust books, as well as forum threads, GitHub issues, and StackOverflow posts I've read and testing I've done.
Please also read the following books for a much more complete understanding of Rust:</p>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><em>The</em> book on Rust (often called the rust book or just the book in discussions)</td><td><a href="https://doc.rust-lang.org/stable/book">Link</a></td></tr>
<tr><td>A collection of examples for common patterns and tasks</td><td><a href="https://doc.rust-lang.org/stable/rust-by-example">Link</a></td></tr>
<tr><td>Guide for Cargo (see also the <a href="./cargo.html">Cargo chapter</a>)</td><td><a href="https://doc.rust-lang.org/cargo/">Link</a></td></tr>
</tbody></table>
<p>A lot of things you already know are going to be re-explained in this guide for two reasons:</p>
<ol>
<li>as a refresher and just to make your understanding is correct</li>
<li>to help explain and draw out differences between the languages; Rust is designed so that the compiler can guarantee some level of correctness in regards to variable access and destruction, and as such it will not compile code it can't predict.</li>
</ol>
<p>Some of the code samples have Ferris on them:</p>
<table><thead><tr><th>Ferris</th><th>Meaning</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain"/></td><td>This code does not compile!</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain"/></td><td>This code panics!</td></tr>
<tr><td><img src="img/ferris/unsafe.svg" class="ferris-explain"/></td><td>This code block contains unsafe code.</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain"/></td><td>This code does not produce the desired behavior.</td></tr>
</tbody></table>
<p>(taken from the official book)</p>
<h1><a class="header" href="#basics" id="basics">Basics</a></h1>
<p>TODO: basic/initial differences summary</p>
<h1><a class="header" href="#syntax-differences" id="syntax-differences">Syntax differences</a></h1>
<p>In Rust...</p>
<ul>
<li>lines have to end with a semicolon, except if it's an implicit return value (like in Kotlin).</li>
<li>methods parameters can not be variadic, named or have default values.</li>
<li>method overloading is not supported.</li>
<li>the naming scheme is <code>snake_case</code> for methods, variables and files; and <code>CamelCase</code> for Traits, Structs, Impls and Enums.</li>
<li>annotations are written like <code>#[example]</code> instead of <code>@Example</code></li>
</ul>
<h1><a class="header" href="#macros" id="macros">Macros</a></h1>
<p>Rust uses macros a lot, this book doesn't cover them as they are beyond it's scope. Macro are invoked by the macro name then an exclamation mark, i.e. <code>example!</code>.</p>
<p>Macros can used like functions <code>example!()</code> but anything can follow the exclamation mark as macros are very powerful, for example:</p>
<pre><code class="language-rust ignore">println!(&quot;Hello World&quot;);

let list = vec![1, 2, 3];

let foo = dsl! {
	init_with_default
	config = bar
}

//At compile time this will invoke the example macro with Foo as the parameter
#[derive(example)]
struct Foo {

}
</code></pre>
<p>The annotation macros will generate code for Structs like AutoValue does for classes.</p>
<p>Macros can generate Rust code at compile time or run and return a result at runtime like a method. </p>
<p>Most programs don't need their own macros but will use ones from std or crates.</p>
<h1><a class="header" href="#primitives" id="primitives">Primitives</a></h1>
<p>In Kotlin there are few commonly used primitive types:</p>
<table><thead><tr><th>Name</th><th>Bits</th><th>Type</th></tr></thead><tbody>
<tr><td>Byte</td><td>8</td><td>Signed Integer</td></tr>
<tr><td>Int</td><td>32</td><td>Signed Integer</td></tr>
<tr><td>Long</td><td>64</td><td>Signed Integer</td></tr>
<tr><td>Float</td><td>32</td><td>Floating Point</td></tr>
<tr><td>Double</td><td>64</td><td>Floating Point</td></tr>
<tr><td>Char</td><td>16</td><td>UTF-16 Character</td></tr>
<tr><td>Boolean</td><td>N/A</td><td>Boolean</td></tr>
</tbody></table>
<p>Currently in Kotlin all the numbers are signed although there are experimental unsigned integers available.</p>
<p>Rust uses a prefix followed by the bit size to create a number type (e.g. i32 meaning a 32 bit integer), these are the prefixes:</p>
<table><thead><tr><th>Character</th><th>Type</th></tr></thead><tbody>
<tr><td>i</td><td>Signed Integer</td></tr>
<tr><td>u</td><td>Unsigned Integer</td></tr>
<tr><td>f</td><td>Floating Point</td></tr>
</tbody></table>
<p>Floating points are 32 and 64 bit only but integers can be 8, 16, 32, 64, and 128 bits; there are also two architecture dependent sizes: <code>isize</code> and <code>usize</code> these are whatever the pointer size is for the CPU (most new computers and phones that is 64 bits). 
As an example the equivalent to a Kotlin <code>Int</code> is <code>i32</code> and a <code>Double</code> is <code>f64</code>. </p>
<p><code>usize</code> is important as it's the primary number type: it's used in array, list and string formatting indexing and lengths/sizes of objects; but it <strong>shouldn't be your default type</strong> as it can be 16, 32 or 64 bits depending on the hardware.</p>
<p>Suffixes for literals exist in Rust like in Kotlin but rather being for some types, suffixes exist for all primitives and they are the name of type, e.g. <code>3_i32</code> or <code>10.3f32</code>, the suffixes are only necessary if the compiler can not infer the type or if you want to specify it; also floating point numbers can be written without the 0, e.g. <code>1.</code></p>
<p>Booleans and Chars are the same in both languages although it's <code>bool</code> instead of <code>Boolean</code>, and <code>char</code> instead of <code>Char</code>. See the <a href="./types_strings.html">Strings chapter</a> for more information about how unicode is handled in Rust.</p>
<h1><a class="header" href="#types-and-variables" id="types-and-variables">Types and variables</a></h1>
<h1><a class="header" href="#mutability" id="mutability">Mutability</a></h1>
<p>Because of the limitations imposed by the JVM in Kotlin variables are mutable or immutable sometimes based on type and sometimes by declaration. In Rust (and some other languages such as Swift) mutability is controlled via declaration:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() { 
	let foo: i32 = 1;     //immutable
	let mut bar: i32 = 2; //mutable
}
</code></pre></pre>
<p>Immutable variables can't be referenced as mutable, so the following will not compile:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
	let foo: i32 = 1; 

	//This is invalid as the variable is immutable and so all 
	//references must be immutable as well
	change_ref(&amp;mut foo); 

	//This is fine as a copy of the value is passed into the 
	//method and only the copy is mutable
	change_val(foo); 
}

fn change_ref(value: &amp;mut i32) {
	*value += 1; 
}

fn change_val(value: mut i32) {
	value += 1;
}
</code></pre>
<p>Note that unlike in Kotlin lists (and any other objects and their properties) in Rust can't be changed if the variable isn't marked as mutable, so the following will not compile:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
	let list = vec![1, 2, 3];

	list.push(4);
}
</code></pre>
<p>See also
<a href="./tips_intmut.html">Interior mutability</a></p>
<h1><a class="header" href="#strings" id="strings">Strings</a></h1>
<p>In both Kotlin and Java, essentially, there is just one String type: String. Whether the text is hardcoded, from a file or user input the same class is used. Rust has two String types: String and str. A hardcoded string will be of type &amp;'static str and a string read from anywhere else maybe a String or &amp;str depending on what the method returns. They can be converted between themselves, in most circumstances.</p>
<p>The String class is a pointer to a string in heap with a capacity, this means it can grow and can be mutable. A str is a char array and so has a fixed length.
If you attempt to slice a string so it would cause a Unicode character to be broken Rust will panic. Use the .chars() method to access each character independently. So to get the length of a string in bytes you use foo.len() and to get the number of characters you use foo.chars().count().</p>
<h1><a class="header" href="#common-types" id="common-types">Common types</a></h1>
<h3><a class="header" href="#lists" id="lists">Lists</a></h3>
<table><thead><tr><th></th><th>Kotlin</th><th>Rust</th></tr></thead><tbody>
<tr><td>Type</td><td>List<T>, MutableList<T>, ArrayList<T></td><td>Vec<T></td></tr>
<tr><td>Constructor</td><td>ArrayList(size), ArrayList(collection)</td><td>Vec::new(), Vec::with_capacity(size)</td></tr>
<tr><td>Shorthand</td><td>listOf(items...), mutableListOf(items...), arrayListOf(items...)</td><td><code>vec![size; default]</code>, <code>vec![items...]</code></td></tr>
</tbody></table>
<h3><a class="header" href="#maps" id="maps">Maps</a></h3>
<table><thead><tr><th></th><th>Kotlin</th><th>Rust</th></tr></thead><tbody>
<tr><td>Type</td><td>Map&lt;K, V&gt;, MutableMap&lt;K, V&gt;, HashMap&lt;K, V&gt;</td><td>HashMap&lt;K, V&gt;</td></tr>
<tr><td>Constructor</td><td>HashMap(size), HashMap(map)</td><td>HashMap::new()</td></tr>
<tr><td>Shorthand</td><td>mapOf(items...), mutableMapOf(items...), hashMapOf(items...)</td><td>N/A <sup class="footnote-reference"><a href="#1">1</a></sup></td></tr>
</tbody></table>
<h3><a class="header" href="#tuples" id="tuples">Tuples</a></h3>
<table><thead><tr><th></th><th>Kotlin</th><th>Rust</th></tr></thead><tbody>
<tr><td>Type</td><td>Pair&lt;T1, T2&gt;, Triple&lt;T1, T2, T3&gt;</td><td>(T1, T2, ...)</td></tr>
<tr><td>Constructor</td><td>Pair(value1, value2), Triple(value1, value2, value3)</td><td>N/A</td></tr>
<tr><td>Shorthand</td><td>value1 to value2</td><td>(value1, value2, ...)</td></tr>
</tbody></table>
<h3><a class="header" href="#arrays" id="arrays">Arrays</a></h3>
<table><thead><tr><th></th><th>Kotlin</th><th>Rust</th></tr></thead><tbody>
<tr><td>Type</td><td>Array<T></td><td>[T]</td></tr>
<tr><td>Constructor</td><td>Array(size, builder_method)</td><td>N/A</td></tr>
<tr><td>Shorthand</td><td>arrayOf(items...)</td><td>[items...]</td></tr>
</tbody></table>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> Crates such as <a href="https://github.com/bluss/maplit">maplit</a> do provide macros for this.</p>
<h1><a class="header" href="#constants" id="constants">Constants</a></h1>
<p>In Rust there are two types of constants <code>const</code> and <code>static</code>. <code>const</code> are immutable values hardcoded into the program. statics are optionally mutable values that are globally available. Using mutable statics is unsafe.</p>
<h1><a class="header" href="#references" id="references">References</a></h1>
<p>All variables can be passed as a reference by prefixing with a &amp;:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
	let foo = 10; 
	print(foo); 
	print_ref(&amp;foo);
}

fn print(value: i32) { 
	//Passed by value so no need to deference
	example(value);
}

fn print_ref(value: &amp;i32) {
	//Dereferenced with *
	example(*value); 
}

fn example(value: i32) {
	//do something with value
}
</code></pre></pre>
<p>Dereferencing a variable moves the value, so the value must implement <code>Copy</code>. See <a href="./classes_deriving.html">Deriving and implementing</a></p>
<p>For clarity:</p>
<table><thead><tr><th>Symbols</th><th>Meaning</th></tr></thead><tbody>
<tr><td>&lt;No symbols&gt;</td><td>Value, immutable</td></tr>
<tr><td>mut</td><td>Value, mutable</td></tr>
<tr><td>&amp;</td><td>Reference, immutable</td></tr>
<tr><td>&amp;mut</td><td>Reference, mutable</td></tr>
<tr><td>*</td><td>Dereferenced</td></tr>
</tbody></table>
<h1><a class="header" href="#borrowing-and-ownership" id="borrowing-and-ownership">Borrowing and Ownership</a></h1>
<p>In Kotlin a variable exists, and is available, while in it’s scope. A global static variable is always available but a variable created in a method (unless returned) only exists during that instance of the methods execution. Rust is basically the same and generally you’ll be able to write code without having to think about the borrowing system, but sometimes you will have to deal with it.</p>
<p>This will not compile as bar has taken ownership of the data in foo and so foo can no longer be used:</p>
<pre><code class="language-rust does_not_compile ignore">let foo = String::from(&quot;Hello&quot;); 
let bar = foo;
println!(&quot;{}&quot;, foo);
</code></pre>
<p>This will compile however as numbers have Copy implemented for them and so num2 automatically makes a copy of num1s data:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num1 = 54;
let num2 = num1; 
println!(&quot;{}&quot;, num1);
<span class="boring">}
</span></code></pre></pre>
<p>but this can be replicated for the string example by doing:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = String::from(&quot;Hello&quot;); 
let bar = foo.clone();
println!(&quot;{}&quot;, foo);
<span class="boring">}
</span></code></pre></pre>
<p>This will only work when the type implemented Clone. Not all types support Clone as it may be impossible to copy it’s data for example with file streams.
Ownership and borrowing apply to all methods:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
	let a = String::from(&quot;Hello&quot;); let b = return_param(a);
	let c = length(b);
    println!(&quot;{}&quot;, c);
}

fn return_param(param: String) -&gt; String { 
	return param;
}

fn length(param: String) -&gt; usize {
	return param.len();
}
</code></pre></pre>
<p>When main is executed both a and b are lost, length takes ownership of the string and it is dropped</p>
<p>at the end of length, to keep b in memory either of the following changes could be made:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">fn main() {
</span><span class="boring">let str = String::from(&quot;test&quot;);
</span><span class="boring">let _ref_len = length_ref(&amp;str);
</span><span class="boring">let (nstr, len) = length(str);
</span><span class="boring">println!(&quot;({},{})&quot;, nstr, len);
</span><span class="boring">}
</span>
fn length_ref(param: &amp;String) -&gt; usize {
	return param.len(); //not dereferenced:
	//because param is a reference len() will return it's result as a reference
	//and because usize implements Copy it will be automatically dereferenced
}

//or

fn length(param: String) -&gt; (String, usize) { 
	let len = param.len();
	return (param, len);
}
</code></pre></pre>
<p>References are just pointers and so don’t take ownership but instead the value is borrowed, there are some rules around this for example only one mutable reference can exist at once. Because of this a potential helpful way to think about this is shared vs unique, you can as many read only references as you want shared around but when writeable only a single unique reference can exist (to avoid race conditions, etc).</p>
<p>Rust supports generics like Kotlin and they are expressed like this: <code>Vec&lt;Item&gt;</code>, occasionally you might see <code>Vec&lt;'a Item&gt;</code> the <code>'a</code> is a lifetime notation and these are used to guide the compiler as to how long references will be alive. The lifetime name doesn’t matter but the standard names are <code>'a</code>, <code>'b</code> and <code>'c</code>, except for <code>'static</code> which means the variable must always be available, i.e. a hardcoded value.</p>
<h1><a class="header" href="#classes-or-the-lack-there-of" id="classes-or-the-lack-there-of">Classes, or the lack there of</a></h1>
<p>In Kotlin has Classes, Abstract Classes, Interfaces, and Extension methods. Rust has Traits, Structs, and Impls. </p>
<h4><a class="header" href="#kotlin" id="kotlin">Kotlin</a></h4>
<ul>
<li>An interface can have methods but can not have variables with values, and may extend another Interface. It can be supplemented with Extension methods or sub classed by other Classes, Abstract Classes or Interfaces.</li>
<li>A class can have variables and methods, and may extend a Class, an Abstract Class and/or Interface(s). It can be supplemented with Extension methods or sub classed by other Classes or Abstract Classes.</li>
<li>An abstract class can have variables and methods, and may extend a Class, an Abstract Class and/or Interface(s). It can be supplemented with Extension methods or sub classed by other Classes or Abstract Classes.</li>
</ul>
<h4><a class="header" href="#rust" id="rust">Rust</a></h4>
<ul>
<li>A trait is like an interface, it defines a list of methods that must be implemented. It can extend other traits, although this is rare.</li>
<li>A struct is the closest thing to a class but although it has a list of variables it does not have any methods. This can not extend anything.</li>
<li>An impl is a collection of methods either matching a Trait (like a Class implementing an Interface) or free form from a struct (like a Class), but Impl are not allowed to have variables and if implementing a Trait can not have methods that are not defined in the Trait. An Impl may be defined repeatedly.</li>
<li>trait and impl can used like Extension Methods (although the syntax is closer to Swift than Kotlin).</li>
</ul>
<p>There is nothing like an abstract class in Rust.</p>
<p>Some Kotlin examples:</p>
<pre><code class="language-kotlin">interface ParentA {
	fun foo() //no method body, just an api
}

interface ParentB : ParentA { //includes methods from parent 
	fun bar() //no method body, just an api
}

class ClassFoo : ParentA { //includes methods from parent 
	var x = 0; //allowed to have variables with values 
	fun foo() {} //methods must be implemented
}

abstract class AbstractClassA: ParentA, ParentB {}

class ClassBar : AbstractClassA() {
	fun foo() {} //methods must be implemented 
	fun bar() {} //from all parents
	fun foobar() {} //can add new methods
}

fun ParentFoo.example1() {} //Adds method called example1 to all
//implementations and children of ParentA
</code></pre>
<p>Some Rust examples:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct StructFoo { //variables only 
	x: i32
}

impl StructFoo {  //methods only, but can access 
	fn foo() {} //variables from Struct
}               //private methods allowed

trait TraitA { //API only 
	fn bar();
}

trait TraitC : TraitA {
	fn boo(); //anything implementing TraitC must implement TraitA separately
}

impl TraitA for StructFoo { //methods only, can not 
	fn bar() {}             //have methods not in the trait
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#deriving-and-implementing" id="deriving-and-implementing">Deriving and implementing</a></h1>
<p>Let’s say you make a type: Person. It has a first name, last name, date of birth, and occupation. It has functions to get the whole name and their age.</p>
<pre><code class="language-rust ignore">use chrono::Date;
use chrono::offset::{*};

struct Person&lt;'a&gt; { 
	first_name: &amp;'a str, 
	last_name: &amp;'a str, 
	date_of_birth: Date&lt;Utc&gt;, 
	occupation: &amp;'a str
}

//Constructors
impl &lt;'a&gt; Person&lt;'a&gt; {
	//no self param means this is a static method 
	fn new(first_name: &amp;'a str,
		last_name: &amp;'a str,
		year: u32,
		month: u32,
		day: u32,
		occupation: &amp;'a str) -&gt; Person&lt;'a&gt; {
		return Person {
			first_name,
			last_name,
			date_of_birth: Utc.ymd(year as i32, month, day), 
			occupation
		}; 
	}
}

//Methods
impl &lt;'a&gt; Person&lt;'a&gt; {
	//self param means this is an instance method 
	//as it's a reference this method does not consume 
	//the object
	fn whole_name(&amp;self) -&gt; String {
		return format!(&quot;{} {}&quot;, self.first_name, self.last_name); 
	}

	fn age_in_years(&amp;self) -&gt; i32 {
		let weeks = Utc::today().signed_duration_since(self.date_of_birth).num_weeks();
		return (weeks / 52) as i32;
	} 

	//the self here isn't a reference so the object
	//is consumed by this method and won't exist
	//after this is method is called
	fn into_tuple(self) -&gt; (String, i32) {
		return (self.whole_name(), self.age_in_years());
	}
}

fn main() {
	//Double colon is for static methods
	let person = Person::new(&quot;John&quot;, &quot;Smith&quot;, 1988, 07, 10, &quot;Author&quot;);
	 
	//Period is for instance methods
	println!(&quot;{} is a {} who is {} years old.&quot;, 
		person.whole_name(), 
		person.occupation, 
		person.age_in_years());
}
</code></pre>
<p>The <code>'a</code> lifetime tells Rust that the <code>&amp;str</code>s will be available as long as the parent <code>Person</code> is.
The sample uses the <code>chrono</code> crate, it is a simple to use and common date and time library. If we want to print the object we must implement the Display like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

<span class="boring">struct Person { 
</span><span class="boring">first_name: String, 
</span><span class="boring">last_name: String, 
</span><span class="boring">occupation: String
</span><span class="boring">}
</span>
impl fmt::Display for Person {
	fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
		return write!(f, &quot;({} {}, {})&quot;, 
			self.first_name, 
			self.last_name, 
			self.occupation);
	} 
}
<span class="boring">}
</span></code></pre></pre>
<p>You can now write <code>println!(&quot;{}&quot;, person)</code>, there are many traits that can be implemented for any struct that’s part of your project.
To avoid boilerplate Rust can automatically derive some traits for structs like so:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Hash, Default)]
struct Foo {} 
<span class="boring">}
</span></code></pre></pre>
<table><thead><tr><th>Trait</th><th>Use</th></tr></thead><tbody>
<tr><td>Debug</td><td>Automatically generates the equivalent of data classes toString(), use with {:?} instead of {}</td></tr>
<tr><td>Clone</td><td>Implements the clone() method on the struct</td></tr>
<tr><td>Copy</td><td>Allows structs to be cloned automatically instead of transferring ownership when assigned to new variable</td></tr>
<tr><td>PartialEq</td><td>Implements equality checking and enables use of the == and != operators on the struct</td></tr>
<tr><td>PartialOrd</td><td>Implements comparison and enables use of the &gt; and &lt; operators on the struct for types where the comparison may be impossible (e.g. floating numbers)</td></tr>
<tr><td>Eq</td><td>Marker trait (like Sync) meaning that all fields can be always and correctly compared, not valid for all types (e.g. floating numbers)</td></tr>
<tr><td>Ord</td><td>Same as PartialOrd but for types where comparison is always possible</td></tr>
<tr><td>Hash</td><td>Automatically generates the equivalent of data classes hashCode(), required to use the struct as key in HashMaps</td></tr>
<tr><td>Default</td><td>Implements a default value for all fields, see <a href="./classes_default.html">Default</a></td></tr>
</tbody></table>
<p>All of these require all the fields in the struct to implement the same traits. Numbers, strings, etc implement all the built in derivable types. As with <code>PartialEq</code> and <code>Eq</code> Rust often has two versions of a trait, one that is allowed to fail (and so will generally return <code>Result</code> or <code>Option</code>) and another that is not allowed to fail. In this case <code>Eq</code> will panic if something goes wrong, likewise there is <code>From</code> and <code>TryFrom</code> for converting structs, <code>From</code> will panic if it fails and <code>TryFrom</code> will return <code>Err</code> if it fails.</p>
<h1><a class="header" href="#default" id="default">Default</a></h1>
<p>If you implement a struct where all the fields have all implemented Default then you don’t have to write out every field when making a new instance of the struct:</p>
<pre><pre class="playground"><code class="language-rust edition2018">#[derive(Default)]
struct Foo { 
	a: i32,
	b: i32,
	c: i32,
	d: String
}

fn main() {
	let foo = Foo::default();
	  
	//You can also supply some of the fields and leave the rest to Default:
	let foo2 = Foo { 
		b: 45,
		d: &quot;Foobar&quot;.to_string(), 
		..Foo::default()
	};
	
	//This is also the syntax for copying:
	let foo3 = Foo { 
		a: 10,
		..foo 
	};
}
</code></pre></pre>
<h1><a class="header" href="#methods" id="methods">Methods</a></h1>
<h1><a class="header" href="#thisself" id="thisself">this/self</a></h1>
<p>A method in a impl for a struct may have a param for the struct, it must always be the first parameter and does not have a name:</p>
<table><thead><tr><th>Parameter</th><th>Meaning</th></tr></thead><tbody>
<tr><td>&lt;None&gt;</td><td>A static method (accessed via ::)</td></tr>
<tr><td>self</td><td>The object itself (this means unless the method returns Self it will dropped after this method)</td></tr>
<tr><td>&amp;self</td><td>A immutable reference to itself</td></tr>
<tr><td>&amp;mut self</td><td>A mutable reference to itself</td></tr>
</tbody></table>
<p>An example:</p>
<pre><code class="language-rust ignore">struct Foo {}

impl Foo {
	fn static_method() {}
	fn mutate(&amp;mut self) {}
	fn clone_and_convert(&amp;self) -&gt; Bar {} 
	fn convert_permanently(self) -&gt; Bar {}
}
</code></pre>
<h1><a class="header" href="#functional-programming" id="functional-programming">Functional Programming</a></h1>
<p>Rust supports lambdas (or closures, etc), the parameters are written comma separated in pipes and the body only requires curly braces if it goes over multiple lines:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let x = vec![1,2,3];
	let y: Vec&lt;usize&gt; = x.iter()
		.map(|it| it + 1)
		.collect();

<span class="boring">println!(&quot;{:?}&quot;, y);
</span><span class="boring">}
</span></code></pre></pre>
<p>Unfortunately with Rust (like Dart) <code>map()</code>, etc return a Map object that has to be converted back into a list using <code>collect()</code>:</p>
<p>Rust also supports higher order functions:</p>
<pre><code class="language-rust ignore">fn foo(f: impl Fn(i32) -&gt; i32)
fn foo&lt;F&gt;(f: F) where F: Fn(i32) -&gt; i32 
fn bar(f: impl MutFn(String) -&gt; usize)
</code></pre>
<p>Fn is a lambda that can not change external state</p>
<p>FnMut is a method that can change external state</p>
<p>FnOnce is a method that can change external state, but is only allowed to be called once</p>
<p>Box allows you to store values on the heap, this is sometimes necessary as the stack can only hold values with a known size (at compile time), as the Box is just a pointer it has a known size unlike, for example, lambdas.</p>
<h1><a class="header" href="#modules" id="modules">Modules</a></h1>
<p>When making a project in Rust you are required to have one file (for programs it’s <code>main.rs</code>, and <code>lib.rs</code> for libraries), it’s also the only file recognised by the compiler. To add a new file to your project you need to add the line (for a file named <code>new_file.rs</code>) to <code>main.rs</code> or <code>lib.rs</code>:</p>
<pre><code class="language-rust ignore">mod new_file;
</code></pre>
<p>Using the following code base:</p>
<pre><code class="language-rust ignore">//main.rs
mod foo; //all Rust files must be referenced here for the compiler to find them 
mod bar;

use crate::bar::foobar;

fn main() { 
	foobar();
}
//foo.rs
pub fn public_method() {} 
fn private_method() {}

//bar.rs
use crate::foo::public_method; 
pub fn foobar() {}
</code></pre>
<p>The foo module has two methods public_method and private_method. private_method is only accessible inside the foo module. The bar module imports the public_method method from the foo module.</p>
<p><code>crate</code> means this project, if using a third party library (for example <code>serde</code>) you would write <code>serde::foo::bar;</code>.</p>
<h1><a class="header" href="#directories" id="directories">Directories</a></h1>
<p>When organising code it is common to group files in a directory. This requires a mod.rs file per directory, at minimum it must reference the other files in the directory to expose them to the compiler:</p>
<pre><code class="language-plaintext">project 
├ main.rs
├ foo.rs
└ bar 
  ├ mod.rs
  └ inner.rs

</code></pre>
<pre><code class="language-rust ignore">//main.rs
mod foo; 
mod bar;

//bar/mod.rs
mod inner;
</code></pre>
<p>This would expose all files to the compiler.</p>
<h1><a class="header" href="#crates" id="crates">Crates</a></h1>
<h1><a class="header" href="#adding-crates" id="adding-crates">Adding crates</a></h1>
<p>Third party libraries are called Crates (and are available from https://crates.io). To add a crate, for example Serde, add this line to Cargo.toml after the [dependencies] line:</p>
<pre><code class="language-toml">serde = &quot;1.0.0&quot;
</code></pre>
<p>You’ll still need to import the individual parts of the crate you want to use, for example:</p>
<pre><code class="language-rust ignore">use serde::json::Serialize;
</code></pre>
<p><code>::Foo</code> means import just Foo</p>
<p><code>::{Foo, Bar}</code> means import Foo and Bar </p>
<p><code>::*</code> means import everything in the module.</p>
<p>You can rename when importing:</p>
<pre><code class="language-rust ignore">use example::Foo as Bar;
</code></pre>
<p>Most of the massive crates have a prelude module that you should import, i.e.</p>
<pre><code class="language-rust ignore">use chrono::prelude::*
</code></pre>
<p>//TODO features</p>
<h1><a class="header" href="#not-in-standard" id="not-in-standard">Not in standard</a></h1>
<p>Some functionality built in to Java/Kotlin isn’t part of the Rust std lib and you’ll need to use these crates to add it:</p>
<table><thead><tr><th>Functionality</th><th>Crate</th><th>Notes</th></tr></thead><tbody>
<tr><td>Random numbers</td><td>rand</td><td>Maintained by Rust team</td></tr>
<tr><td>Serialization</td><td>serde</td><td>Does XML, JSON, protobuf, etc</td></tr>
<tr><td>Lazy static variables</td><td>lazy_static</td><td></td></tr>
<tr><td>Regix</td><td>regex</td><td>Maintained by Rust team</td></tr>
<tr><td>Base64</td><td>base64</td><td></td></tr>
<tr><td>UUID</td><td>uuid</td><td></td></tr>
<tr><td>Enums</td><td>strum</td><td>Enum features variant names, properties, count, list, ordinal</td></tr>
</tbody></table>
<h1><a class="header" href="#common-crates" id="common-crates">Common crates</a></h1>
<p>These crates are the closest equivalent to the commonly used Kotlin libraries:</p>
<table><thead><tr><th>Kotlin</th><th>Rust</th><th>Notes</th></tr></thead><tbody>
<tr><td>GSON</td><td><a href="https://serde.rs/">serde</a></td><td>Much more powerful and flexible than GSON</td></tr>
<tr><td>JodaTime</td><td><a href="https://github.com/chronotope/chrono">chrono</a></td><td>Essentially the same</td></tr>
<tr><td>JDBC</td><td><a href="https://github.com/diesel-rs/diesel">diesel</a></td><td>Works with multiple databases</td></tr>
</tbody></table>
<h1><a class="header" href="#result-option-and-exceptions" id="result-option-and-exceptions">Result, Option and Exceptions</a></h1>
<h1><a class="header" href="#result-and-exceptions" id="result-and-exceptions">Result and exceptions</a></h1>
<p>Result&lt;V, E&gt; is used for when a method may fail, it can contain the result or an error. It is created via <code>Ok()</code> and <code>Err()</code></p>
<pre><code class="language-rust ignore">fn get(&amp;self, idx: u32) -&gt; Result&lt;Item, String&gt; { 
	if self.contains(idx) {
		Ok(self[idx]) 
	} else {
		Err(&quot;404&quot;) 
	}
}

fn main() {
	let result = foo.get(10);
	match result {
		Ok(item) =&gt; println!(item), 
		Err(e) =&gt; println!(e)
	} 
}
</code></pre>
<p>You can also do the equivalent of <code>var!!</code> with both Option and Result by using <code>var.unwrap()</code> and <code>var.expect(&quot;some message&quot;)</code>. Both methods will crash the app if it’s Err/None, expect() will also write the message to the console.</p>
<p>To avoid having to write unwrap() every time if you’re in a method that returns a Result you can just write <code>var?</code>, if <code>var</code> is an Err the method will return the Err immediately.</p>
<p>To crash a Rust program you should use <code>panic!(&quot;message&quot;)</code>. This will print the message and stacktrace to the command line.</p>
<h1><a class="header" href="#option-and-nulls" id="option-and-nulls">Option and nulls</a></h1>
<p><code>Option&lt;T&gt;</code>s are the same as <code>Optional&lt;T&gt;</code>s and quite like nullable values and are created via <code>Some()</code> and <code>None</code></p>
<pre><pre class="playground"><code class="language-rust edition2018">fn divide(numerator: f64, denominator: f64) -&gt; Option&lt;f64&gt; { 
	if denominator == 0.0 {
		None //notice no return and no semicolon 
	} else {
        Some(numerator / denominator)
    } //the last value in a method is automatically returned
} //assuming no return call 

fn main() {
	let result = divide(2.0, 3.0);
	match result {
		Some(x) =&gt; println!(&quot;Result: {}&quot;, x), 
		None =&gt; println!(&quot;Cannot divide by 0&quot;),
	}
}
</code></pre></pre>
<h1><a class="header" href="#concurrency" id="concurrency">Concurrency</a></h1>
<p>To pass values safely between threads you need to use Mutexes or Atomic values in most languages, Rust is no different. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use std::thread;
use std::sync::atomic::{AtomicI8, Ordering};
use std::sync::Arc;
use std::time::Duration;

fn main() {
    //AtomicXX implement Sync meaning they can be used 
    //in multiple threads safely
    //Arc (Atomically Reference Counted) allows for multiple, independent
    //references of a single value to exist outside of the borrow checker
    //for a tiny overhead by counting the number of references that
    //exist (like in Swift) 
    let number = Arc::new(AtomicI8::new(0i8));
    //Make a copy of the arc, any number of copies can exist
    let thread_number = number.clone();

    //move means this lambda is taking ownership of any variable
    //it uses, this is necessary for lambdas executed in a different
    //context e.g. in a different thread
    thread::spawn(move || {
        let mut i = 0;
        loop {
            //ordering controls how the atomic value is set/read
            //You should probably always use SeqCst
            thread_number.store(i, Ordering::SeqCst);
            i += 1;
            thread::sleep(Duration::from_millis(500));
            if i &gt; 10 {
                break;
            }
        }
        println!(&quot;Done&quot;);
    });

    loop {
        println!(&quot;{}&quot;, number.load(Ordering::SeqCst));
        if number.load(Ordering::SeqCst) &gt;= 10 {
            break;
        }
    }
}
</code></pre></pre>
<p>This program will continually print out the value stored in <code>number</code> until the thread reaches 10</p>
<h1><a class="header" href="#testing" id="testing">Testing</a></h1>
<p>The standard in Rust is to have the tests in a module inside the module being tested, the test module needs to be annotated as do all the tests:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//foo.rs 

fn add(value1: i32, value2: i32) -&gt; i32 {
  value1 + value2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_all() {
        assert_eq!(2, add(1, 1));
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#cargo" id="cargo">Cargo</a></h1>
<p>To run and build programs from the command line you should always use cargo (outside of an IDE):</p>
<pre><code class="language-bash">#Build debug version
cargo build

#Run debug version
cargo run

#Run tests
cargo test

#Build release version
cargo build --release
</code></pre>
<p>Other command line options:</p>
<pre><code class="language-bash">#Format all code
cargo fmt

#Linter
cargo clippy

#These have to be installed first by
rustup update
rustup component add rustfmt
rustup component add clippy
</code></pre>
<h1><a class="header" href="#tools" id="tools">Tools</a></h1>
<h1><a class="header" href="#enums" id="enums">Enums</a></h1>
<p>Unfortunately enums in Rust work they do in Swift and so no default values can be provided and instead you have to add methods which use matches to provide values:</p>
<pre><pre class="playground"><code class="language-rust edition2018">enum MobileOs {
  Android, Ios, Windows
}

impl MobileOs {
  fn status(&amp;self) -&gt; &amp;str {
    match self {
      MobileOs::Android =&gt; return &quot;alive&quot;,
      MobileOs::Ios =&gt; return &quot;alive&quot;,
      MobileOs::Windows =&gt; return &quot;dead&quot;,
    }
  }
}

fn main() {
  println!(&quot;{}&quot;, MobileOs::Android.status());
}
</code></pre></pre>
<p>Thankfully they can also work like sealed classes:</p>
<pre><pre class="playground"><code class="language-rust edition2018">enum Example {
  Foo { named_value: i32 },
  Tuple(u8, u8),
  Empty
}

fn main() {
  let foo = Example::Foo { named_value: 45 };
  let tuple = Example::Tuple(1, 2);
  let empty = Example::Empty;
}
</code></pre></pre>
<p>When coming from other modern languages you be expecting the ability to get a variant count, list or names and add static values to each variant but unfortunately Rust enums do not support any of these features, but all of these can be added with the strum crate.</p>
<h1><a class="header" href="#useful-crates" id="useful-crates">Useful crates</a></h1>
<h1><a class="header" href="#tips-and-tricks" id="tips-and-tricks">Tips and tricks</a></h1>
<h1><a class="header" href="#if-let" id="if-let">if let</a></h1>
<p>Like in Swift an Option can be unwrapped in an if if there is a value:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_method(optional_string: Option&lt;String&gt;) {
  if let Some(string_value) = optional_string {
    println!(&quot;Does exist: {}&quot;, string_value);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>This also works for Result but use Ok instead of Some. If you need to handle both states you should use match as an if let throws away the other value:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_method(optional_string: Option&lt;String&gt;) {
  match optional_string {
    Some(string_value) =&gt; println!(&quot;Does exist: {}&quot;, string_value),
    None =&gt; println!(&quot;No content&quot;)
  }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#reference-counting" id="reference-counting">Reference counting</a></h1>
<p>Sometimes you need bypass the borrow checker, for example, you want to use a reference as a pointer to an item in a collection or you’re passing values between threads. To do this you use the Arc (Atomically Reference Counted) class, it adds a small overhead in the form of a count and some extra code to monitor and update the count. Arc will keep the value alive as long as any Arc value is still alive, when the last Arc value is dropped the value will be as well. To make multiple references to an value protected by Arc clone it:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use std::sync::Arc;

fn main() {
  let some_heap_thing = Thing::new();
  let arc_thing = Arc::new(some_heap_thing);
  thread1(arc_thing.clone()); 
  thread2(arc_thing.clone()); 
}

fn thread1(thing: Arc&lt;Thing&gt;) {
  thing.methods_accessed_in_normal_way();
}

<span class="boring">fn thread2(thing: Arc&lt;Thing&gt;) {}
</span><span class="boring">struct Thing {}
</span><span class="boring">impl Thing { 
</span><span class="boring">fn new() -&gt; Thing {Thing {} } 
</span><span class="boring">fn methods_accessed_in_normal_way(&amp;self) {}
</span><span class="boring">}
</span></code></pre></pre>
<p>The value in the Arc can not be mutable unless it’s contained in another class, as the value will need to be protected against concurrent updates, the wrapper types are Mutex and RwLock. The differences are that RwLock will allow any number of concurrent readers but only one writer and Mutex only allows one reader or writer at a time. </p>
<h1><a class="header" href="#converting-strings" id="converting-strings">Converting strings</a></h1>
<p>Often when writing a function that takes a piece of text you’ll want to support both String and &amp;str to be more convenient to the caller. This is best achieved by using Into<String> The Into trait tells the compiler to allow any parameter that be coerced as that type to be passed in. Both String and &amp;str already have the Into<String> trait but it can also be implemented for any struct. Into<X> for Y is automatically implemented for any type that implements From<Y> for X which is actually how it’s implemented for Strings and is the recommended approach.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print&lt;S: Into&lt;String&gt;&gt;(value: S) { 
	println!(&quot;{}&quot;, value.into());
}
<span class="boring">}
</span></code></pre></pre>
<p>Unfortunately you can’t use Into<String> as a generic (unless the type supports it), for example with Option&lt;Into<String>&gt; as Option would need to have special support to know how to coerce the values.</p>
<h1><a class="header" href="#interior-mutability" id="interior-mutability">Interior mutability</a></h1>
<p>Sometimes you need to have a mutable value but can only pass it around as a value or reference, to achieve you can use the <code>Cell</code> structs.</p>
<p><code>Cell</code> is a wrapper around a value that can be changed at any point.</p>
<p><code>RefCell</code> is the same as <code>Cell</code> but allows the value to be exposed as a reference.</p>
<p><code>RwLock</code> is the same as <code>RefCell</code> but can be shared across threads.</p>
<p><code>Mutex</code> is the same as <code>RefCell</code> but can make references that can be shared across threads. </p>
<p>All of these are safe, they use reference counting and/or memory swapping to update values.</p>
<h1><a class="header" href="#indexed-iteration" id="indexed-iteration">Indexed iteration</a></h1>
<p>Kotlin provides forEach, map, filter, etc for iterators but these only give you the element if you also need the index as Kotlin provides forEachIndexed, mapIndexed, filterIndexed, etc</p>
<pre><code class="language-kotlin">list.forEach { element -&gt;
	println(element)
}
list.forEachIndexed { i, element -&gt; 
	println(&quot;${i}: ${element}&quot;)
} 
</code></pre>
<p>Rust also has this feature but it works differently, instead of different methods the iterator type is changed via enumerate:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let list = vec![&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
</span>list.iter()
	.for_each(|element| println!(&quot;{}&quot;, element));

list.iter()
	.enumerate()
	.for_each(|(i, element)| println!(&quot;{}: {}&quot;, i, element));
<span class="boring">}
</span></code></pre></pre>
<p>This has the downside that all later operators must also handle the index as well.</p>
<h1><a class="header" href="#formatting-strings" id="formatting-strings">Formatting strings</a></h1>
<p>To format a string, the easiest (and correct) way is to use <code>format!(string, parameters...)</code>. String formatting in Rust uses {} as placeholders for parameters.</p>
<p>Basics:</p>
<p><code>&quot;{}&quot;</code> will print the result of Display::fmt(), this must be manually implemented &quot;{:?}&quot; will print the result of Debug::fmt(), this can be derived</p>
<p><code>&quot;{:#?}&quot;</code> will pretty print the result of Debug::fmt()</p>
<p><code>&quot;{example}&quot;</code> will print parameter named example</p>
<p><code>&quot;{2}&quot;</code> will print the third parameter</p>
<p>Padding:</p>
<p><code>&quot;{:&gt;5}&quot;</code> Left pad with up to 5 spaces</p>
<p><code>&quot;{:&lt;7}&quot;</code> Right pad with up to 7 spaces</p>
<p><code>&quot;{:^22}&quot;</code> Centre with up to 11 spaces on both sides</p>
<p>Padding with any character:</p>
<p><code>&quot;{:_&gt;5}&quot;</code> Left pad with up to 5 underscores &quot;{:#&lt;7}&quot; Right pad with up to 7 hashes &quot;{:c^22}&quot; Centre with up to 11 ’c’s on both sides</p>
<p>Numbers:</p>
<p><code>&quot;{:.3}&quot;</code> Will print 3 fractional digits (adding 0s on the end if necessary) but only if it’s a floating point number</p>
<p><code>&quot;{:+3}&quot;</code> Print sign</p>
<p><code>&quot;{:03}&quot;</code> Print at least 3 digits (padding with 0s on the start if necessary), if negative the minus symbol will replace a 0</p>
<p>Example: <code>format!(&quot;{:&gt;5} {named}&quot;, &quot;Foo&quot;, named=123)</code></p>
<p>To have variable parts (such as variable length padding) use this syntax:</p>
<p><code>(&quot;{1:.0$}&quot;, 1, 1.22)</code></p>
<p>This will print 1.2, the syntax is <code>{value_index:.precision_index$}</code></p>
<p><code>(&quot;{1:=&lt;0$}&quot;, 10, &quot;test&quot;)</code></p>
<p>This will print test======, the syntax is <code>{value_index:padding_char&lt;length_index$}</code></p>
<p>Note that invalid parameter details are ignored silently and treated as {}. If debugging via logging consider using dgb!():</p>
<pre><code class="language-rust ignore">let x;
x = dbg!(1 * 4); 
</code></pre>
<p>prints
<code>[src/main.rs:3] 1 * 4 = 4</code></p>
<h1><a class="header" href="#for-crates" id="for-crates">For crates</a></h1>
<h2><a class="header" href="#date-formatting" id="date-formatting">Date Formatting</a></h2>
<h4><a class="header" href="#chrono" id="chrono">Chrono</a></h4>
<p>Using <code>DateTimeFormat.forPattern(&quot;&lt;pattern&gt;&quot;).print(DateTime.now())</code> for Kotlin and <code>Utc::now().format(&quot;&lt;pattern&gt;&quot;)</code> for Rust.</p>
<table><thead><tr><th></th><th>Kotlin/JodaTime</th><th>Rust/Chrono</th><th>Example</th></tr></thead><tbody>
<tr><td>Date</td><td><code>yyyy-MM-dd</code></td><td><code>%Y-%M-%D</code></td><td>2000-01-01</td></tr>
<tr><td>Text Date</td><td><code>dd MMM yyyy</code></td><td><code>%e %b %Y</code></td><td>15 Jun 2004</td></tr>
<tr><td>Time</td><td><code>HH:mm:ss</code></td><td><code>%H:%M:%S</code></td><td>14:12:56</td></tr>
<tr><td>to ISO 8601</td><td><code>DateTime.now().toString()</code></td><td><code>Utc::now().to_rfc3339_opts( SecondsFormat::Millis, true)</code></td><td>1996-12-19T16:39:57.000Z</td></tr>
<tr><td>from ISO 8601</td><td><code>DateTime.parse</code></td><td><code>Utc::parse_from_rfc_3339</code></td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#json-parsing" id="json-parsing">JSON Parsing</a></h2>
<h4><a class="header" href="#serde" id="serde">Serde</a></h4>
<p>Add this to <code>cargo.toml</code>:</p>
<pre><code class="language-toml">serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0&quot;
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="language-kotlin">data class Example(
    val name: String,
    @SerializedName(&quot;num&quot;)
    val someNumber: Int
)

fun convert(json: String, example: Example) {
    val outputExample: Example = Gson().fromJson&lt;Example&gt;(json, Example::class.java)
    val outputJson: String = Gson().toJson(example)
}
</code></pre>
<p><strong>Rust</strong></p>
<pre><code class="language-rust ignore">#[derive(Serialize,Deserialize)]
struct Example {
    name: String,
    #[serde(rename = &quot;num&quot;)]
    some_number: i32
}

fn convert(json: String, example: Example) {
    let output_example: Example = serde_json::from_str(&amp;json).unwrap();
    let output_json: String = serde_json::to_string(&amp;example).unwrap();
}
</code></pre>
<h1><a class="header" href="#common-bugsissues" id="common-bugsissues">Common bugs/issues</a></h1>
<h3><a class="header" href="#cloning-a-reference-returns-a-reference-despite-the-signature-being-a-value" id="cloning-a-reference-returns-a-reference-despite-the-signature-being-a-value">Cloning a reference returns a reference despite the signature being a value</a></h3>
<p>This can because the struct doesn’t implement/derive Clone.</p>
<h3><a class="header" href="#cannot-move-out-of-borrowed-content-when-using-unwrap" id="cannot-move-out-of-borrowed-content-when-using-unwrap">cannot move out of borrowed content when using unwrap()</a></h3>
<p>This is because unwrap() consumes the reference (it’s self parameter is just self), to fix this use variable.as_ref().unwrap().</p>
<h1><a class="header" href="#architecture" id="architecture">Architecture</a></h1>
<p>Kotlin is an object orientated language which means that generally data and methods are grouped together in classes and it’s very rare to have methods outside of classes even though Kotlin fully supports this. Also classes can extend each other so a lot of frameworks (such as Android or AWT) rely heavily on inheritance to provide functionality to classes.</p>
<p>Rust is a data orientated language, and programs will more resemble C programs where a program may be made of a few methods and a few structs without any impls. And as impl inheritance is impossible in Rust and trait inheritance doesn’t really add much use, composition is used a lot.</p>
<p>That said grouping logic and data is still fine and done with Rust:</p>
<pre><code class="language-kotlin">class Point( 
	val x: Float, 
	val y: Float
){
	fun distanceTo(other: Point): Float {...}
	fun angleTo(other: Point): Float {...} 
}
</code></pre>
<p>can become</p>
<pre><code class="language-rust ignore">struct Point {
	x: f32,
	y: f32 
}

impl Point {
	fn new(x: f32, y: f32) -&gt; Point {
		return Point {x, y}; 
	}
}

impl Point {
	fn distance_to(other: Point) -&gt; f32 {...}
	fn angle_to(other: Point) -&gt; f32 {...} 
}
</code></pre>
<h1><a class="header" href="#resources" id="resources">Resources</a></h1>
<h2><a class="header" href="#tutorials" id="tutorials">Tutorials</a></h2>
<p><a href="https://rust-unofficial.github.io/too-many-lists">Linked List</a>
An in depth guide on how to implement a linked list in Rust</p>
<p><a href="https://github.com/sunjay/tic-tac-toe">Tic-Tac-Toe</a>
This project is heavily commented and is an example of idiomatic and well written Rust.</p>
<p><a href="https://bitbucket.org/raybritton/kotlin-rust-comparison">Language Comparison</a>
These both contain files with the common patterns (constants, lambdas, etc) implemented in both languages were possible, they are coded in the correct style for their respective languages</p>
<p><a href="https://github.com/raybritton/rosetta-roman-numerals">Roman Numerals</a>
This contains CLI programs created in multiple languages that converts Roman numerals into decimal numbers and vice versa, the programs have the same methods, tests and functionality</p>
<h2><a class="header" href="#rust-community" id="rust-community">Rust Community</a></h2>
<p><a href="https://www.reddit.com/r/rust">Official subreddit</a></p>
<p><a href="https://www.reddit.com/r/learnrust">Subreddit for beginners</a></p>
<p><a href="https://discord.gg/rust-lang">Discord</a></p>
<p><a href="https://this-week-in-rust.org">Weekly newsletter</a></p>
<h2><a class="header" href="#references-1" id="references-1">References</a></h2>
<p><a href="https://doc.rust-lang.org/stable/reference">Language reference</a></p>
<p><a href="https://doc.rust-lang.org/stable/edition-guide/rust-2018">Guide for changes in 2018 edition of Rust</a> (This should only be needed for converting old code)</p>
<h2><a class="header" href="#other" id="other">Other</a></h2>
<p><a href="https://play.rust-lang.org">Playground</a></p>
<p><a href="https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html">Rust: A Unique Perspective</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="ferris.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
