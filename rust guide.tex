\documentclass[a4paper,11pt]{article}

\usepackage{xparse}
\usepackage{array}
\usepackage[dvipsnames]{xcolor}
\usepackage{listings}
\usepackage[margin=1.2in]{geometry}
\usepackage{color}   
\usepackage[hidelinks]{hyperref}
\hypersetup{
    colorlinks=false,
    linktoc=all,     
}

\lstdefinelanguage{Kotlin}{
  comment=[l]{//},
  commentstyle={\color{gray}\ttfamily},
  emph={delegate, filter, first, firstOrNull, forEach, lazy, map, mapNotNull, println, return@},
  emphstyle={\color{OrangeRed}},
  identifierstyle=\color{black},
  keywords={abstract, actual, as, as?, break, by, class, companion, continue, data, do, dynamic, else, enum, expect, false, final, for, fun, get, if, import, in, interface, internal, is, null, object, override, package, private, public, return, set, super, suspend, this, throw, true, try, typealias, val, var, vararg, when, where, while},
  keywordstyle={\color{NavyBlue}\bfseries},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
  morestring=[s]{"""*}{*"""},
  ndkeywords={@Deprecated, @JvmField, @JvmName, @JvmOverloads, @JvmStatic, @JvmSynthetic, Array, Boolean, Byte, Double, Float, Int, Integer, Iterable, Long, Runnable, Short, String},
  ndkeywordstyle={\color{BurntOrange}\bfseries},
  sensitive=true,
  stringstyle={\color{ForestGreen}\ttfamily},
}

\lstdefinelanguage{Rust}{%
  sensitive%
, morecomment=[l]{//}%
, morecomment=[s]{/*}{*/}%
, moredelim=[s][{\itshape\color[rgb]{0,0,0.75}}]{\#[}{]}%
, morestring=[b]{"}%
, alsodigit={}%
, alsoother={}%
, alsoletter={!}%
%
%
% [1] reserve keywords
% [2] traits
% [3] primitive types
% [4] type and value constructors
% [5] identifier
%
, morekeywords={break, continue, else, for, if, in, loop, match, return, while}  % control flow keywords
, morekeywords={as, const, let, move, mut, ref, static}  % in the context of variables
, morekeywords={dyn, enum, fn, impl, Self, self, struct, trait, type, union, use, where}  % in the context of declarations
, morekeywords={crate, extern, mod, pub, super}  % in the context of modularisation
, morekeywords={unsafe}  % markers
, morekeywords={abstract, alignof, become, box, do, final, macro, offsetof, override, priv, proc, pure, sizeof, typeof, unsized, virtual, yield}  % reserved identifiers
%
% grep 'pub trait [A-Za-z][A-Za-z0-9]*' -r . | sed 's/^.*pub trait \([A-Za-z][A-Za-z0-9]*\).*/\1/g' | sort -u | tr '\n' ',' | sed 's/^\(.*\),$/{\1}\n/g' | sed 's/,/, /g'
, morekeywords=[2]{Add, AddAssign, Any, AsciiExt, AsInner, AsInnerMut, AsMut, AsRawFd, AsRawHandle, AsRawSocket, AsRef, Binary, BitAnd, BitAndAssign, Bitor, BitOr, BitOrAssign, BitXor, BitXorAssign, Borrow, BorrowMut, Boxed, BoxPlace, BufRead, BuildHasher, CastInto, CharExt, Clone, CoerceUnsized, CommandExt, Copy, Debug, DecodableFloat, Default, Deref, DerefMut, DirBuilderExt, DirEntryExt, Display, Div, DivAssign, DoubleEndedIterator, DoubleEndedSearcher, Drop, EnvKey, Eq, Error, ExactSizeIterator, ExitStatusExt, Extend, FileExt, FileTypeExt, Float, Fn, FnBox, FnMut, FnOnce, Freeze, From, FromInner, FromIterator, FromRawFd, FromRawHandle, FromRawSocket, FromStr, FullOps, FusedIterator, Generator, Hash, Hasher, Index, IndexMut, InPlace, Int, Into, IntoCow, IntoInner, IntoIterator, IntoRawFd, IntoRawHandle, IntoRawSocket, IsMinusOne, IsZero, Iterator, JoinHandleExt, LargeInt, LowerExp, LowerHex, MetadataExt, Mul, MulAssign, Neg, Not, Octal, OpenOptionsExt, Ord, OsStrExt, OsStringExt, Packet, PartialEq, PartialOrd, Pattern, PermissionsExt, Place, Placer, Pointer, Product, Put, RangeArgument, RawFloat, Read, Rem, RemAssign, Seek, Shl, ShlAssign, Shr, ShrAssign, Sized, SliceConcatExt, SliceExt, SliceIndex, Stats, Step, StrExt, Sub, SubAssign, Sum, Sync, TDynBenchFn, Terminal, Termination, ToOwned, ToSocketAddrs, ToString, Try, TryFrom, TryInto, UnicodeStr, Unsize, UpperExp, UpperHex, WideInt, Write}
, morekeywords=[2]{Send}  % additional traits
%
, morekeywords=[3]{bool, char, f32, f64, i8, i16, i32, i64, isize, str, u8, u16, u32, u64, unit, usize, i128, u128}  % primitive types
%
, morekeywords=[4]{Err, false, None, Ok, Some, true}  % prelude value constructors
% grep 'pub \(type\|struct\|enum\) [A-Za-z][A-Za-z0-9]*' -r . | sed 's/^.*pub \(type\|struct\|enum\) \([A-Za-z][A-Za-z0-9]*\).*/\2/g' | sort -u | tr '\n' ',' | sed 's/^\(.*\),$/{\1}\n/g' | sed 's/,/, /g'    
, morekeywords=[3]{AccessError, Adddf3, AddI128, AddoI128, AddoU128, ADDRESS, ADDRESS64, addrinfo, ADDRINFOA, AddrParseError, Addsf3, AddU128, advice, aiocb, Alignment, AllocErr, AnonPipe, Answer, Arc, Args, ArgsInnerDebug, ArgsOs, Argument, Arguments, ArgumentV1, Ashldi3, Ashlti3, Ashrdi3, Ashrti3, AssertParamIsClone, AssertParamIsCopy, AssertParamIsEq, AssertUnwindSafe, AtomicBool, AtomicPtr, Attr, auxtype, auxv, BackPlace, BacktraceContext, Barrier, BarrierWaitResult, Bencher, BenchMode, BenchSamples, BinaryHeap, BinaryHeapPlace, blkcnt, blkcnt64, blksize, BOOL, boolean, BOOLEAN, BoolTrie, BorrowError, BorrowMutError, Bound, Box, bpf, BTreeMap, BTreeSet, Bucket, BucketState, Buf, BufReader, BufWriter, Builder, BuildHasherDefault, BY, BYTE, Bytes, CannotReallocInPlace, cc, Cell, Chain, CHAR, CharIndices, CharPredicateSearcher, Chars, CharSearcher, CharsError, CharSliceSearcher, CharTryFromError, Child, ChildPipes, ChildStderr, ChildStdin, ChildStdio, ChildStdout, Chunks, ChunksMut, ciovec, clock, clockid, Cloned, cmsgcred, cmsghdr, CodePoint, Color, ColorConfig, Command, CommandEnv, Component, Components, CONDITION, condvar, Condvar, CONSOLE, CONTEXT, Count, Cow, cpu, CRITICAL, CStr, CString, CStringArray, Cursor, Cycle, CycleIter, daddr, DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple, Decimal, Decoded, DecodeUtf16, DecodeUtf16Error, DecodeUtf8, DefaultEnvKey, DefaultHasher, dev, device, Difference, Digit32, DIR, DirBuilder, dircookie, dirent, dirent64, DirEntry, Discriminant, DISPATCHER, Display, Divdf3, Divdi3, Divmoddi4, Divmodsi4, Divsf3, Divsi3, Divti3, dl, Dl, Dlmalloc, Dns, DnsAnswer, DnsQuery, dqblk, Drain, DrainFilter, Dtor, Duration, DwarfReader, DWORD, DWORDLONG, DynamicLibrary, Edge, EHAction, EHContext, Elf32, Elf64, Empty, EmptyBucket, EncodeUtf16, EncodeWide, Entry, EntryPlace, Enumerate, Env, epoll, errno, Error, ErrorKind, EscapeDebug, EscapeDefault, EscapeUnicode, event, Event, eventrwflags, eventtype, ExactChunks, ExactChunksMut, EXCEPTION, Excess, ExchangeHeapSingleton, exit, exitcode, ExitStatus, Failure, fd, fdflags, fdsflags, fdstat, ff, fflags, File, FILE, FileAttr, filedelta, FileDesc, FilePermissions, filesize, filestat, FILETIME, filetype, FileType, Filter, FilterMap, Fixdfdi, Fixdfsi, Fixdfti, Fixsfdi, Fixsfsi, Fixsfti, Fixunsdfdi, Fixunsdfsi, Fixunsdfti, Fixunssfdi, Fixunssfsi, Fixunssfti, Flag, FlatMap, Floatdidf, FLOATING, Floatsidf, Floatsisf, Floattidf, Floattisf, Floatundidf, Floatunsidf, Floatunsisf, Floatuntidf, Floatuntisf, flock, ForceResult, FormatSpec, Formatted, Formatter, Fp, FpCategory, fpos, fpos64, fpreg, fpregset, FPUControlWord, Frame, FromBytesWithNulError, FromUtf16Error, FromUtf8Error, FrontPlace, fsblkcnt, fsfilcnt, fsflags, fsid, fstore, fsword, FullBucket, FullBucketMut, FullDecoded, Fuse, GapThenFull, GeneratorState, gid, glob, glob64, GlobalDlmalloc, greg, group, GROUP, Guard, GUID, Handle, HANDLE, Handler, HashMap, HashSet, Heap, HINSTANCE, HMODULE, hostent, HRESULT, id, idtype, if, ifaddrs, IMAGEHLP, Immut, in, in6, Incoming, Infallible, Initializer, ino, ino64, inode, input, InsertResult, Inspect, Instant, int16, int32, int64, int8, integer, IntermediateBox, Internal, Intersection, intmax, IntoInnerError, IntoIter, IntoStringError, intptr, InvalidSequence, iovec, ip, IpAddr, ipc, Ipv4Addr, ipv6, Ipv6Addr, Ipv6MulticastScope, Iter, IterMut, itimerspec, itimerval, jail, JoinHandle, JoinPathsError, KDHELP64, kevent, kevent64, key, Key, Keys, KV, l4, LARGE, lastlog, launchpad, Layout, Lazy, lconv, Leaf, LeafOrInternal, Lines, LinesAny, LineWriter, linger, linkcount, LinkedList, load, locale, LocalKey, LocalKeyState, Location, lock, LockResult, loff, LONG, lookup, lookupflags, LookupHost, LPBOOL, LPBY, LPBYTE, LPCSTR, LPCVOID, LPCWSTR, LPDWORD, LPFILETIME, LPHANDLE, LPOVERLAPPED, LPPROCESS, LPPROGRESS, LPSECURITY, LPSTARTUPINFO, LPSTR, LPVOID, LPWCH, LPWIN32, LPWSADATA, LPWSAPROTOCOL, LPWSTR, Lshrdi3, Lshrti3, lwpid, M128A, mach, major, Map, mcontext, Metadata, Metric, MetricMap, mflags, minor, mmsghdr, Moddi3, mode, Modsi3, Modti3, MonitorMsg, MOUNT, mprot, mq, mqd, msflags, msghdr, msginfo, msglen, msgqnum, msqid, Muldf3, Mulodi4, Mulosi4, Muloti4, Mulsf3, Multi3, Mut, Mutex, MutexGuard, MyCollection, n16, NamePadding, NativeLibBoilerplate, nfds, nl, nlink, NodeRef, NoneError, NonNull, NonZero, nthreads, NulError, OccupiedEntry, off, off64, oflags, Once, OnceState, OpenOptions, Option, Options, OptRes, Ordering, OsStr, OsString, Output, OVERLAPPED, Owned, Packet, PanicInfo, Param, ParseBoolError, ParseCharError, ParseError, ParseFloatError, ParseIntError, ParseResult, Part, passwd, Path, PathBuf, PCONDITION, PCONSOLE, Peekable, PeekMut, Permissions, PhantomData, pid, Pipes, PlaceBack, PlaceFront, PLARGE, PoisonError, pollfd, PopResult, port, Position, Powidf2, Powisf2, Prefix, PrefixComponent, PrintFormat, proc, Process, PROCESS, processentry, protoent, PSRWLOCK, pthread, ptr, ptrdiff, PVECTORED, Queue, radvisory, RandomState, Range, RangeFrom, RangeFull, RangeInclusive, RangeMut, RangeTo, RangeToInclusive, RawBucket, RawFd, RawHandle, RawPthread, RawSocket, RawTable, RawVec, Rc, ReadDir, Receiver, recv, RecvError, RecvTimeoutError, ReentrantMutex, ReentrantMutexGuard, Ref, RefCell, RefMut, REPARSE, Repeat, Result, Rev, Reverse, riflags, rights, rlim, rlim64, rlimit, rlimit64, roflags, Root, RSplit, RSplitMut, RSplitN, RSplitNMut, RUNTIME, rusage, RwLock, RWLock, RwLockReadGuard, RwLockWriteGuard, sa, SafeHash, Scan, sched, scope, sdflags, SearchResult, SearchStep, SECURITY, SeekFrom, segment, Select, SelectionResult, sem, sembuf, send, Sender, SendError, servent, sf, Shared, shmatt, shmid, ShortReader, ShouldPanic, Shutdown, siflags, sigaction, SigAction, sigevent, sighandler, siginfo, Sign, signal, signalfd, SignalToken, sigset, sigval, Sink, SipHasher, SipHasher13, SipHasher24, size, SIZE, Skip, SkipWhile, Slice, SmallBoolTrie, sockaddr, SOCKADDR, sockcred, Socket, SOCKET, SocketAddr, SocketAddrV4, SocketAddrV6, socklen, speed, Splice, Split, SplitMut, SplitN, SplitNMut, SplitPaths, SplitWhitespace, spwd, SRWLOCK, ssize, stack, STACKFRAME64, StartResult, STARTUPINFO, stat, Stat, stat64, statfs, statfs64, StaticKey, statvfs, StatVfs, statvfs64, Stderr, StderrLock, StderrTerminal, Stdin, StdinLock, Stdio, StdioPipes, Stdout, StdoutLock, StdoutTerminal, StepBy, String, StripPrefixError, StrSearcher, subclockflags, Subdf3, SubI128, SuboI128, SuboU128, subrwflags, subscription, Subsf3, SubU128, Summary, suseconds, SYMBOL, SYMBOLIC, SymmetricDifference, SyncSender, sysinfo, System, SystemTime, SystemTimeError, Take, TakeWhile, tcb, tcflag, TcpListener, TcpStream, TempDir, TermInfo, TerminfoTerminal, termios, termios2, TestDesc, TestDescAndFn, TestEvent, TestFn, TestName, TestOpts, TestResult, Thread, threadattr, threadentry, ThreadId, tid, time, time64, timespec, TimeSpec, timestamp, timeval, timeval32, timezone, tm, tms, ToLowercase, ToUppercase, TraitObject, TryFromIntError, TryFromSliceError, TryIter, TryLockError, TryLockResult, TryRecvError, TrySendError, TypeId, U64x2, ucontext, ucred, Udivdi3, Udivmoddi4, Udivmodsi4, Udivmodti4, Udivsi3, Udivti3, UdpSocket, uid, UINT, uint16, uint32, uint64, uint8, uintmax, uintptr, ulflags, ULONG, ULONGLONG, Umoddi3, Umodsi3, Umodti3, UnicodeVersion, Union, Unique, UnixDatagram, UnixListener, UnixStream, Unpacked, UnsafeCell, UNWIND, UpgradeResult, useconds, user, userdata, USHORT, Utf16Encoder, Utf8Error, Utf8Lossy, Utf8LossyChunk, Utf8LossyChunksIter, utimbuf, utmp, utmpx, utsname, uuid, VacantEntry, Values, ValuesMut, VarError, Variables, Vars, VarsOs, Vec, VecDeque, vm, Void, WaitTimeoutResult, WaitToken, wchar, WCHAR, Weak, whence, WIN32, WinConsole, Windows, WindowsEnvKey, winsize, WORD, Wrapping, wrlen, WSADATA, WSAPROTOCOL, WSAPROTOCOLCHAIN, Wtf8, Wtf8Buf, Wtf8CodePoints, xsw, xucred, Zip, zx}
%
, morekeywords=[5]{assert!, assert_eq!, assert_ne!, cfg!, column!, compile_error!, concat!, concat_idents!, debug_assert!, debug_assert_eq!, debug_assert_ne!, env!, eprint!, eprintln!, file!, format!, format_args!, include!, include_bytes!, include_str!, line!, module_path!, option_env!, panic!, print!, println!, select!, stringify!, thread_local!, try!, unimplemented!, unreachable!, vec!, write!, writeln!}  % prelude macros
}%

\lstdefinestyle{colouredRust}%
{ basicstyle=\ttfamily%
, identifierstyle=%
, commentstyle=\color[gray]{0.4}%
, stringstyle=\color[rgb]{0, 0, 0.5}%
, keywordstyle=\bfseries% reserved keywords
, keywordstyle=[2]\color[rgb]{0.75, 0, 0}% traits
, keywordstyle=[3]\color[rgb]{0, 0.5, 0}% primitive types
, keywordstyle=[4]\color[rgb]{0, 0.5, 0}% type and value constructors
, keywordstyle=[5]\color[rgb]{0, 0, 0.75}% macros
, columns=spaceflexible%
, keepspaces=true%
, showspaces=false%
, showtabs=false%
, showstringspaces=true%
}%

\lstdefinestyle{boxed}{
  style=colouredRust%
, numbers=left%
, firstnumber=auto%
, numberblanklines=true%
, frame=trbL%
, numberstyle=\tiny%
, frame=leftline%
, numbersep=7pt%
, framesep=5pt%
, framerule=10pt%
, xleftmargin=15pt%
, backgroundcolor=\color[gray]{0.97}%
, rulecolor=\color[gray]{0.90}%
}

\begin{document}

\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}
\lstset{language=Rust, style=colouredRust}
\setlength{\parindent}{0mm}
\hyphenpenalty 10000
\exhyphenpenalty 10000
\sffamily

\title{A guide to Rust for Kotlin developers}
\author{Ray Britton}
\date{March 2019}

\pagenumbering{gobble}
\maketitle

\newpage
\pagenumbering{gobble}
\tableofcontents

\newpage
\pagenumbering{arabic}
\section{Introduction}

This document should help developers experienced with Kotlin quickly and easily learn the basics of Rust by comparing the major differences but also how the languages, by the nature of them both being modern languages, have quite a few similiar features.
\newline
\newline
This book is a summary of the offical Rust books, as well as forum threads, Github issues, and StackOverflow posts I've read and testing I've done.
Please read the following books (in this order) for a much more complete understanding of Rust:
\begin{itemize}
  \item https://doc.rust-lang.org/stable/book
  \item https://doc.rust-lang.org/stable/rust-by-example
  \item https://doc.rust-lang.org/stable/edition-guide/rust-2018
  \item https://doc.rust-lang.org/stable/reference
\end{itemize}
A lot of things you already know are going to be re-explained in this document for two reasons:
\begin{enumerate}
	\item as a refresher and just to make your understanding is correct
	\item to help explain and draw out differences between the languages
\end{enumerate}
When code is shown inline it will appear as \lstinline[language=Kotlin]{Boolean} for Kotlin and \lstinline[language=Rust]{bool} for Rust.

\subsection{Core differences}
In Rust...
\begin{itemize}
	\item lines to end with a semicolon.
  \item there is an offical and very opiniated linter - it should always be used.
  \item methods parameters can be variadic, named or have default values.
  \item methods can have the same name as another in the same scope.
  \item the naming scheme is \lstinline{snake_case} for methods and variables, and \lstinline{CamelCase} for Traits, Structs, Impls and Enums.
\end{itemize}

\newpage
\section{Types and Variables}
\subsection{Primitives}
In Kotlin there are few commonly used primitive types:

\renewcommand{\arraystretch}{1.3}

\begin{center}
\begin{tabular}{ c|c|c } 
 
 Name & Bits & Type \\ 
 \hline
 Int & 32 & Signed Integer \\ 
 Long & 64 & Signed Integer \\ 
 Float & 32 & Floating Point \\ 
 Double & 64 & Floating Point \\ 
 Char & 32 & Character \\ 
 Boolean & N/A & Boolean \\ 
 
\end{tabular}
\end{center}

Like in Java Strings are not primitives but are often treated as such, the number types are signed.
Kotlin currently has unsigned versions of integers under discussion.
\newline
\newline
Rust uses a different system for naming number types which a character followed by a number:

\begin{center}
\begin{tabular}{ c|c } 

 Character & Type \\ 
 \hline
 i & Signed Integer \\ 
 f & Floating point \\ 
 u & Unsigned Integer \\ 
 
\end{tabular}
\end{center}

\renewcommand{\arraystretch}{1}
Floating points support 32 and 64 only but integers can be 8, 16, 32, 64, and 128; there are also two architecture dependent sizes: \lstinline[language=Rust]{isize} and \lstinline[language=Rust]{usize} these are whatever the word size is for the CPU (for 99\% of new Androids that is 64). For example the equivalent to a Kotlin \lstinline[language=Kotlin]{Int} is \lstinline[language=Rust]{i32} and a \lstinline[language=Kotlin]{Double} is \lstinline[language=Rust]{f64}.
\newline
Booleans and Chars are the same (although the keyword is \lstinline[language=Rust]{bool} instead of \lstinline[language=Kotlin]{Boolean}, and \lstinline[language=Rust]{char} instead of \lstinline[language=Kotlin]{Char}).

\subsection{Strings}
In both Kotlin and Java, essentially, there is just one String type: \lstinline[language=Kotlin]{String}. Whether the text is hardcoded, from a file or user input the same class is used.
Rust has two String types: \lstinline[language=Rust]{String} and \lstinline[language=Rust]{str}. A hardcoded string will be of type \lstinline[language=Rust]{str} and a string read from anywhere else maybe a \lstinline[language=Rust]{String} or \lstinline[language=Rust]{str} depending on what the method returns. They can be converted between themselves at any time infintely.
\newline
The \lstinline[language=Rust]{String} is a pointer to a string in heap with a capacity, this means it can grow and can be mutable. A \lstinline[language=Rust]{str} is a char arry and so has a fixed length.
\newline
Like with \lstinline[language=Kotlin]{String}s when you substring a \lstinline[language=Rust]{str} the new variable uses the original variables backing data, however unlike in Kotlin/Java where is unknown (and basically irrelevant as the backing array can't be changed without reflection) this is how all arrays work in Rust. Using part of an array is called slicing and changing the contents of slice (e.g. substring) will change the original variables data.
\newline
\newline
It's also worthing notes that you can't actually directly substring with Rust as the language designers wanted you to be sure whether you meant bytes, characters or grapheme clusters; so the string has to be accessed in different ways to expose the individual parts.

\subsection{Common types}
\begin{center}
\begin{tabular}{ |>{\raggedright\arraybackslash}p{2.5cm}|>{\raggedright\arraybackslash}p{5.8cm}|>{\raggedright\arraybackslash}p{5.8cm}| } 
 \hline
   & \textbf{Kotlin} & \textbf{Rust} \\ 
 \hline
 \multicolumn{3}{|c|}{\textbf{Lists}} \\
 \hline
 \textbf{Type} & \lstinline[language=Kotlin]|List<T>|, \lstinline[language=Kotlin]|MutableList<T>|, \lstinline[language=Kotlin]|ArrayList<T>| & \lstinline[language=Rust]|Vec<T>| \\
 \textbf{Constructor} & \lstinline[language=Kotlin]|List(|\emph{size},\emph{default}\lstinline[language=Kotlin]|)|, \lstinline[language=Kotlin]|MutableList(|\emph{size},\emph{default}\lstinline[language=Kotlin]|)|, \lstinline[language=Kotlin]|ArrayList(|\emph{size}|\emph{Collection}\lstinline[language=Kotlin]|)| & \lstinline[language=Rust]|Vec::new()| \\
 \textbf{Creation methods} & \lstinline[language=Kotlin]|listOf(|\emph{vararg items}\lstinline[language=Kotlin]|)|, \lstinline[language=Kotlin]|mutableListOf(|\emph{vararg items}\lstinline[language=Kotlin]|)|, etc & \lstinline[language=Rust]|vec![|\emph{size};\emph{default}\lstinline[language=Rust]|]|, \lstinline[language=Rust]|vec![|\emph{vararg items}\lstinline[language=Rust]|]| \\
 \hline
 \multicolumn{3}{|c|}{\textbf{Maps}} \\
 \hline
 \textbf{Type} & \lstinline[language=Kotlin]|Map<K, V>|, \lstinline[language=Kotlin]|MutableMap<K, V>|, \lstinline[language=Kotlin]|HashMap<K, V>| & \lstinline[language=Rust]|HashMap<K: Hash & Eq, V>| \\
 \textbf{Constructor} & \lstinline[language=Kotlin]|List(|\emph{vararg pairs}\lstinline[language=Kotlin]|)|, \lstinline[language=Kotlin]|MutableList(|\emph{vararg pairs}\lstinline[language=Kotlin]|)|, \lstinline[language=Kotlin]|HashMap(|\emph{size}|\emph{Collection}\lstinline[language=Kotlin]|)| & \lstinline[language=Rust]|HashMap::new()| \\
 \textbf{Creation methods} & \lstinline[language=Kotlin]|mapOf(|\emph{vararg pairs}\lstinline[language=Kotlin]|)|, \lstinline[language=Kotlin]|mutableMapOf(|\emph{vararg pairs}\lstinline[language=Kotlin]|)|, etc & N/A \\
 \hline
 \multicolumn{3}{|c|}{\textbf{Tuples}} \\
 \hline
 \textbf{Type} & & \\
 \textbf{Constructor} & & \\
 \textbf{Creation methods} & & \\
 \hline
 \multicolumn{3}{|c|}{\textbf{TODO}} \\
 \hline
 \textbf{Type} & & \\
 \textbf{Constructor} & & \\
 \textbf{Creation methods} & & \\
 \hline
\end{tabular}
\end{center}

\subsection{Mutability}
Because of the limitations imposed by the JVM in Kotlin variables are mutable or immutable based on type rather than by notation, in Rust (and some other languages such as Swift) all data types are both immutable and mutable and their mutability is controlled via notation:
\begin{lstlisting}[language=Rust,frame=single]
let foo: i32 = 1;
let mut bar: i32 = 2;
\end{lstlisting}
In the above snippet \lstinline{foo} will always be 1 but \lstinline{bar} can be changed. A variable can not become mutable:
\begin{lstlisting}[language=Rust,frame=single]
let foo: i32 = 1;

change(&mut foo);

fn change(value: &mut i32) {
	value += 1;
}
\end{lstlisting}
This will not compile as \lstinline{foo} is immutable and so can't be made (or referenced as) mutable.

\newpage
\section{References}
All variables can be passed as a reference, Rust will often automatically deference pointers which makes this quite pain less to use:
\begin{lstlisting}[language=Rust,frame=single]
let foo = 10;
print(foo);
print_ref(foo);

fn print(value: i32) {
	println!(value); 
	//Passed by value so no need to deference
}

fn print_ref(value: &i32) {
	println!(value); //Automatically deferenced
}


let mut bar = 65;
change(bar);

fn change(value: &mut i32) {
	*bar += 1; 
	//Has to be deferenced as Rust doesn't perform 
	//automatic deference with operators (as you 
	//might want to do pointer math, it is
	//currently under discussion though)
} 

\end{lstlisting}

For clarity:
\begin{center}
\begin{tabular}{ |c|c| } 
 \hline
 Symbols & Meaning \\ 
 \hline
 <No symbols> & Value, immutable \\ 
 mut & Value, mutable \\ 
 \& & Refernce, immutable \\ 
 \&mut & Refernce, mutable \\ 
 \hline
\end{tabular}
\end{center}

\newpage
\section{Borrowing and Ownership}
In Kotlin a variable exists, and is available, while in it's scope. A global static variable is always available but a variable created in a method (unless returned) only exists during that instance of the methods executon. Rust is basically the same and generally you'll be able to write code without having to think about the borrowing system, but sometimes you will have to deal with it.
\begin{lstlisting}[language=Rust,frame=single]
fn main() {
    
    let a = String::from("Hello");
    let b = a;
    
    println!("{}", a);
}
\end{lstlisting}

This will not compile as \lstinline{b} has taken ownership of the data in \lstinline{a} and so \lstinline{a} can no longer be used.

\begin{lstlisting}[language=Rust,frame=single,caption={Listing B}]
fn main() {
    
    let a = 54;
    let b = a;
    
    println!("{}", a);
}
\end{lstlisting}

This will compile however as numbers have \lstinline[language=Rust]{Copy} implemented for them and so \lstinline{b} automatically makes a copy of \lstinline{a}s data, this can be replicated for the string example by doing:

\begin{lstlisting}[language=Rust,frame=single]
fn main() {
    
    let a = String::from("Hello");
    let b = a.clone();
    
    println!("{}", a);
}
\end{lstlisting}
\newpage
Ownership and borrowing apply to all methods so:

\begin{lstlisting}[language=Rust,frame=single]
fn main() {
    let a = String::from("Hello");
    let b = return_param(a);
    let c = length(b);

    println!("{}", c);
}

fn return_param(param: String) -> String {
	return param;
}

fn length(param: String) -> usize {
	return param.len();
}
\end{lstlisting}

When \lstinline{c} is printed both \lstinline{a} and \lstinline{b} are lost, \lstinline{length} takes ownership of the string and it is dropped at the end of \lstinline{length}, to keep \lstinline{b} in memory either of the following changes could be made:
\begin{lstlisting}[language=Rust,frame=single]
fn length(param: &String) -> usize {
	return param.len(); //automatically deferenced
}

//or

fn length(param: String) -> (String, usize) {
	return (param, param.len()); 
}
\end{lstlisting}

References are just references and so don't take ownership but instead the value is borrowed, there are some rules around this for example only one mutable reference can exist at once.

Rust supports generics like Kotlin and they are expressed like this: \lstinline{Vec<Item>}, occasionally you might see \lstinline{Vec<'a Item>} the \lstinline{'a} is a lifetime notation and these are used to instruct the compiler when to drop the generic items. The name doesn't matter but the standard names are \lstinline{'a}, \lstinline{'b} and \lstinline{'c}.

\newpage
\section{Classes, or the lack there of}

In Kotlin there are Classes, Abstract Classes, Interfaces, and Extension methods. Each of these might be able to store data or provide funcationality or an API.
Rust has Traits, Structs and Impls.
\newline
\textbf{Kotlin}
\begin{itemize}
  \item An \lstinline[language=Kotlin]{Interface} can have methods but can not have variables (with values), and may extend another Interface. It can be supplmented with Extension methods or sub classed by other Classes, Abstract Classes or Interfaces.
  \item A \lstinline[language=Kotlin]{Class} can have variables and methods, and may extend a Class, an Abstract Class and/or an Interface. It can be supplmented with Extension methods or sub classed by other Classes or Abstract Classes.
  \item An \lstinline[language=Kotlin]{abstract Class} can have variables and methods, and may extend a Class, an Abstract Class and/or an Interface. It can be supplmented with Extension methods or sub classed by other Classes or Abstract Classes.
\end{itemize}
\textbf{Rust}
\begin{itemize}
  \item A \lstinline[language=Rust]{trait} is like an interface, it defines a list of methods that must be implemented. It can extend other \lstinline[language=Rust]{trait}s.
  \item A \lstinline[language=Rust]{struct} is like a class (or a struct from C), it has a list of variables but unlike a class does not have any methods. This can not extend anything.
  \item An \lstinline[language=Rust]{impl} is a collection of methods either matching a \lstinline[language=Rust]{Trait} (like a \lstinline[language=Kotlin]{Class} implementing an \lstinline[language=Kotlin]{Interface}) or free form from a \lstinline[language=Rust]{struct} (like a \lstinline[language=Kotlin]{Class}), but Impl are not allowed to have variables and if implementing a Trait can not have methods that are not defined in the Trait. An Impl may be defined repeatedly.
  \item \lstinline[language=Rust]{trait} and \lstinline[language=Rust]{impl} can used like Extension Methods (although the syntax is closer to Swift than Kotlin).
\end{itemize}

\newpage
Some Kotlin examples:
\begin{lstlisting}[language=Kotlin,frame=single]
interface ParentA {
  fun foo() //no method body, just an api
}

interface ParentB : ParentA { //includes methods from parent
  fun bar() //no method body, just an api
}

class ClassA : ParentA { //includes methods from parent
  var x = 0; //allowed to have variables with values
  fun foo() {} //methods must be implemented
}

abstract class AbstractClassA : ParentB {
  fun foobar() //no method body
}

class ClassB : AbstractClassA() {
  fun foo() {} //methods must be implemented
  fun bar() {} //from all parents
  fun foobar() {}
}

fun ParentA.example1() {} //Adds method called example1 to all
fun ClassB.example2() {} //implementions and children of ParentA
\end{lstlisting}

Some Rust examples:
\begin{lstlisting}[language=Rust,frame=single]
struct StructA { //variables only
  x: i32 = 0 
}

impl StructA { //methods only, but can access
  fn foo() {}  //variables from Struct 
}              //private methods allowed

trait TraitA { //API only
  fn bar();
}

trait TraitC : TraitA {
  fn boo();
}

impl TraitA { //methods only, can have 
  fn bar() {} //private methods
}

trait TraitB { //API only
  fn foobar();
}

impl TraitB for StructA {
  fn foobar() {} //methods only but can access
}                //variables and methods from Struct
                 //no private methods allowed
\end{lstlisting}

A \lstinline[language=Rust]{trait} can only be implemented if the \lstinline[language=Rust]{trait} or \lstinline[language=Rust]{struct} is defined in your app/lib. For example, if we want to add a pad method to String:

\begin{lstlisting}[language=Rust,frame=single]
trait Pad {
  fn pad(&self) -> Self
}

impl Pad for String {
  fn pad(&self) -> String {
    return " ".to_string() + self;
  }
}
\end{lstlisting}
TODO
but...

\subsection{Deriving and implementing}
Let's say you make a type: \lstinline{Person}. It will have a first name, last name, date of birth, and occupation. It will also have functions to get the whole name and their age.

\begin{lstlisting}[language=Rust,frame=single]
extern crate chrono;

use chrono::Date;
use chrono::offset::{*};

struct Person {
  first_name: String,
  last_name: String,
  date_of_birth: Date<Utc>,
  occupation: String
}

//Constructors
impl Person {
  //no self param means this is a static method
  fn new(first_name: &str, 
      last_name: &str, 
      year: u32,
      month: u32, 
      day: u32, 
      occupation: &str) -> Person {
    return Person {
      first_name: first_name.to_string(),
      last_name: last_name.to_string(),
      date_of_birth: Utc.ymd(year as i32, month, day),
      occupation: occupation.to_string()
    }
  }
}

//Methods
impl Person {
    //self param means this is an instance method
    fn whole_name(&self) -> String {
        return format!("{} {}", self.first_name, self.last_name);
    }  
    
    fn age_in_years(&self) -> i32 {
        let weeks = Utc::today().signed_duration_since(self.date_of_birth)
            .num_weeks();
        return (weeks / 52) as i32;
    }
}

fn main() {
    //Double colon is for static methods
    let person = Person::new("John", "Smith", 1988, 07, 10, "Author");
    
    //Period is for instance methods
    println!("{} is a {} who is {} years old.", 
        person.whole_name(), 
        person.occupation, 
        person.age_in_years());
}
\end{lstlisting}

The sample uses the \lstinline{chrono} crate, it is a simple to use date and time library. 
If we want to print the object (i.e. create a \lstinline{to\_string()} method) we must implement the \lstinline{Display} like this:

\begin{lstlisting}[language=Rust,frame=single]
use std::fmt;

impl fmt::Display for Person {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        return write!(f, "({} {}, {})", 
            self.first_name, 
            self.last_name, 
            self.occupation);
    }
}
\end{lstlisting}

You can now write \lstinline[language=Rust]{println!(person)}, there are many \lstinline[language=Rust]{trait}s that can be implemented for any \lstinline[language=Rust]{struct}.\newline
To avoid boilerplate Rust can automatically derive some \lstinline[language=Rust]{trait}s for \lstinline[language=Rust]{struct}s like so:
\begin{lstlisting}[language=Rust,frame=single]
#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Hash, Default)]
struct Foo {}
\end{lstlisting}

\begin{center}
\begin{tabular}{ |c|p{12cm}| } 
 \hline
 Trait & Use \\ 
 \hline
 Debug & Automatically generates the equivalent of \lstinline[language=Kotlin]|data class|es \lstinline[language=Kotlin]|toString()|, use with \lstinline[language=Rust]|{:?}| instead of \lstinline[language=Rust]|{}| \\
 Clone & Implements the \lstinline[language=Rust]|clone()| method on the struct \\
 Copy & Allows structs to be copied instead of transfering ownership when assigned to new variable \\
 PartialEq & Implements equality checking and enables use of the == and != operators on the \lstinline[language=Rust]|struct| \\
 PartialOrd & Implements comparison and enables use of the > and < operators on the \lstinline[language=Rust]|struct| for types where the comparison may be impossible (i.e. floating numbers)\\
 Eq & Allows for === (is same object) checking, not valid for all types (i.e. floating numbers) \\
 Ord & Same as PartialOrd but for types where comparison is always possible\\
 Hash & Automatically generates the equivalent of \lstinline[language=Kotlin]|data class|es \lstinline[language=Kotlin]|hashCode()|, required to use the \lstinline[language=Rust]|struct| as key in \lstinline[language=Rust]|HashMap|s \\
 Default & Implements a default value for all feilds, see below \\
 \hline
\end{tabular}
\end{center}

All of these require all the fields in the struct to implement the same traits, all numbers, strings, etc implement all the built in derivable types.

\newpage
\subsection{Default}

If you implement a \lstinline[language=Rust]{struct} where all the fields have all implemented \lstinline[language=Rust]{Default} then you don't have to write out every field when making a new instance of the \lstinline[language=Rust]{struct}:

\begin{lstlisting}[language=Rust,frame=single]
#[derive(Default)]
struct Foo {
  a: i32,
  b: i32,
  c: i32,
  d: String
}

fn main() {
  let foo = Foo::default();

  //You can also supply some of the fields and leave the rest to Default:
  let foo2 = Foo {
    b: 45,
    d: "Foobar".to_string(),
    ..Foo::default()
  };
}
\end{lstlisting}

\newpage
\section{Method syntax}
\subsection{this/self}

A method in a \lstinline[language=Rust]{impl} for a \lstinline[language=Rust]{struct} may have a param for the \lstinline[language=Rust]{struct}, it must always be the first parameter and does not have a name:
\begin{center}
\begin{tabular}{ |c|p{12cm}| } 
 \hline
 Parameter & Meaning \\ 
 \hline
 <None> & A static method (accessed via ::) \\
 self & The object itself (this means unless the method returns Self it will dropped after this method) \\ 
 \&self  & A immutable reference to itself \\ 
 \&mut self & A mutable reference to itself \\ 
 \hline
\end{tabular}
\end{center}

An example:
\begin{lstlisting}[language=Rust,frame=single]
struct Foo {}

impl Foo {
  fn static() {}
  fn mutate(&mut self) {}
  fn clone_and_convert(&self) -> Bar {}
  fn convert_permanently(self) -> Bar {}
}
\end{lstlisting}

Statements and expersions must have a semicolon at the end except if it's the last

\subsection{Functional Programming}

Rust supports higher order functions, using them is quite easy:

\begin{lstlisting}[language=Rust,frame=single]
let x = vec![1,2,3]; 
let y = x.map(|it| it + 1);
\end{lstlisting}

Rust supports higher order functions but the syntax is quite different:
\begin{lstlisting}[language=Rust,frame=single]
fn foo(f: impl Fn(i32) -> i32)
fn bar(f: impl MutFn(String) -> usize)
let method: Box<Fn(usize) -> i32> = {}
\end{lstlisting}

\lstinline[language=Rust]{Fn} is a method that takes an immutable reference and returns a value
\newline
\lstinline[language=Rust]{FnMut} is a method that takes an mutable reference and returns a value
\newline
\lstinline[language=Rust]{FnOnce} is a method that takes a value and returns a value (dropping the original value)
\newline
\lstinline{method} is a reference to a method

TODO
Box is a ...

\newpage
\section{Modules}
When making a project in Rust you are required to have one file (for programs it's \lstinline{main.rs}, and \lstinline{lib.rs} for libraries), it's also the only file recongised by the compiler. To add a new file (called a \lstinline{module}) to your project you need to add the line (for a file named \lstinline{new_file.rs}):
\begin{lstlisting}[language=Rust,frame=single]
mod new_file;
\end{lstlisting}

TODO
If the file in a directory you need to....

Using the following code base:
\begin{lstlisting}[language=Rust,frame=single]
//main.rs 
mod foo;
mod bar;

use crate::bar::foobar;

fn main() {
  foobar();
}


//foo.rs
pub fn public_method() {}
fn private_method() {}


//bar.rs
use crate::foo::public_method;

pub fn foobar() {}
\end{lstlisting}

The \lstinline{foo} module has two methods \lstinline{public_method} and \lstinline{private_method}. \lstinline{private_method} is only accessible inside the \lstinline{foo} module.
The \lstinline{bar} module imports the \lstinline{public_method} method from the \lstinline{foo} module.
\newline
\lstinline{crate} means this project, if using a third party library (for example \lstinline{serde}) you would write \lstinline{serde::foo::bar;}.

TODO
In file modules...

\newpage
\section{Crates}
\subsection{Adding crates}
Third party libraries are called \lstinline{Crates} (and are available from \lstinline{https://crates.io}). To add a crate, for example \lstinline{Serde}: 
Add this line to \lstinline{Cargo.toml} after the \lstinline{[dependencies]} line:
\begin{lstlisting}[language=Rust,frame=single]
serde = "1.0.0"
\end{lstlisting}
Add this line to \lstinline{main.rs} at the top:
\begin{lstlisting}[language=Rust,frame=single]
extern crate serde;
\end{lstlisting}

You'll still need to import the individual parts of the crate you want to use, for example:
\begin{lstlisting}[language=Rust,frame=single]
use serde::json::{*};
\end{lstlisting}
\lstinline|{*}| means import everything in the module.

\subsection{Not standard}
Some funtionality built in to Java/Kotlin isn't part of the std lib and you'll need to use these crates to add it:

\renewcommand{\arraystretch}{1.3}

\begin{center}
\begin{tabular}{ c|c|l } 

 Functionality & Crate & Notes \\ 
 \hline
 Random numbers & \lstinline|rand| & Maintained by Rust team \\
 Serialization & \lstinline|serde| & Also does XML, JSON, etc \\
 Lazy variables & \lstinline|lazy_static| & Only static variables \\
 Regex & \lstinline|regex| & Maintained by Rust team \\
 Base64 & \lstinline|base64| & \\
 UUID & \lstinline|uuid| & \\
 
\end{tabular}
\end{center}

\subsection{Common crates}
These crates are closest equalivent to the commonly used Kotlin libraries:
\begin{center}
\begin{tabular}{ c|c|l } 
 Kotlin & Rust & Notes \\ 
 \hline
 GSON & Serde & Much more powerful and flexible than GSON \\
 JodaTime & Chrono & Essentially the same \\
 RxJava & RxRust & Abandoned, incomplete \\
\end{tabular}
\end{center}

\renewcommand{\arraystretch}{1}

\newpage
\section{Result, Option and Exceptions}

\newpage
\section{Concurrency}

\newpage
\section{Macros}

\newpage
\section{Testing}

\newpage
\section{Cargo}


\end{document}